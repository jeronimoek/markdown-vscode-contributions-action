import "core-js/modules/es.string.replace-all.js";
import "core-js/modules/es.string.match-all.js";
import "core-js/modules/es.array.push.js";
import "core-js/modules/es.error.cause.js";
import { Contributions } from "./enums.mjs";
import stringWidth from "string-width";
function flattenObject(obj) {
  const flattened = {};
  Object.keys(obj).forEach(key => {
    const value = obj[key];
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      Object.assign(flattened, flattenObject(value));
    } else {
      flattened[key] = value;
    }
  });
  return flattened;
}
function propsNestedObject(contributionArr) {
  return contributionArr.map(contribution => flattenObject(contribution));
}
function propsPlain(contributionArr) {
  return contributionArr;
}
function propsWithAreas(contributions) {
  return Object.keys(contributions).flatMap(area => {
    return contributions[area].map(contribution => ({
      ...contribution,
      area
    }));
  });
}
function propsConfiguration(settings) {
  return Object.keys(settings.properties).map(property => {
    return {
      ...settings.properties[property],
      property,
      title: settings.title,
      order: settings.order
    };
  });
}
function propsDebuggers(debuggers) {
  return debuggers.map(currentDebugger => {
    var _currentDebugger$stri, _currentDebugger$linu, _currentDebugger$osx, _currentDebugger$wind;
    return {
      ...currentDebugger,
      unverifiedBreakpoints: (_currentDebugger$stri = currentDebugger.strings) === null || _currentDebugger$stri === void 0 ? void 0 : _currentDebugger$stri.unverifiedBreakpoints,
      linuxRuntime: (_currentDebugger$linu = currentDebugger.linux) === null || _currentDebugger$linu === void 0 ? void 0 : _currentDebugger$linu.runtime,
      osxRuntime: (_currentDebugger$osx = currentDebugger.osx) === null || _currentDebugger$osx === void 0 ? void 0 : _currentDebugger$osx.runtime,
      windowsRuntime: (_currentDebugger$wind = currentDebugger.windows) === null || _currentDebugger$wind === void 0 ? void 0 : _currentDebugger$wind.runtime
    };
  });
}
function propsDocumentation(documentation) {
  return documentation.refactoring;
}
function propsIcons(icons) {
  return Object.keys(icons).map(iconId => {
    return {
      ...flattenObject(icons[iconId]),
      iconId
    };
  });
}
function propsFlatObjectOrObjectArray(contributionArr) {
  return [contributionArr].flat();
}

// TODO: missing "quickFixes" data
function propsTerminalProfiles(terminal) {
  return terminal.profiles.map(profile => flattenObject(profile));
}
function propsSemanticTokenScopes(semanticTokenScopes) {
  return semanticTokenScopes.map(semanticTokenScope => {
    const {
      language,
      scopes
    } = semanticTokenScope;
    return Object.keys(scopes).map(scope => {
      return scopes[scope].map(fallbackScope => ({
        language,
        scope,
        fallbackScope
      }));
    });
  }).flat(3);
}
function propsProblemMatchers(problemMatchers) {
  return problemMatchers.map(problemMatcher => {
    var _problemMatcher$backg, _problemMatcher$backg2, _problemMatcher$backg3, _problemMatcher$backg4, _problemMatcher$backg5, _problemMatcher$backg6, _problemMatcher$backg7, _problemMatcher$backg8, _problemMatcher$backg9;
    return {
      ...problemMatcher,
      activeOnStart: (_problemMatcher$backg = problemMatcher.background) === null || _problemMatcher$backg === void 0 ? void 0 : _problemMatcher$backg.activeOnStart,
      beginsPatternFile: (_problemMatcher$backg2 = problemMatcher.background) === null || _problemMatcher$backg2 === void 0 ? void 0 : (_problemMatcher$backg3 = _problemMatcher$backg2.beginsPattern) === null || _problemMatcher$backg3 === void 0 ? void 0 : _problemMatcher$backg3.file,
      beginsPatternRegexp: (_problemMatcher$backg4 = problemMatcher.background) === null || _problemMatcher$backg4 === void 0 ? void 0 : (_problemMatcher$backg5 = _problemMatcher$backg4.beginsPattern) === null || _problemMatcher$backg5 === void 0 ? void 0 : _problemMatcher$backg5.regexp,
      endsPatternFile: (_problemMatcher$backg6 = problemMatcher.background) === null || _problemMatcher$backg6 === void 0 ? void 0 : (_problemMatcher$backg7 = _problemMatcher$backg6.endsPattern) === null || _problemMatcher$backg7 === void 0 ? void 0 : _problemMatcher$backg7.file,
      endsPatternRegexp: (_problemMatcher$backg8 = problemMatcher.background) === null || _problemMatcher$backg8 === void 0 ? void 0 : (_problemMatcher$backg9 = _problemMatcher$backg8.endsPattern) === null || _problemMatcher$backg9 === void 0 ? void 0 : _problemMatcher$backg9.regexp,
      ...problemMatcher.pattern
    };
  });
}
function propsArray(contributions) {
  return contributions.map(contribution => ({
    data: contribution
  }));
}
function propsConfigurationDefaults(configurationDefaults) {
  return Object.keys(configurationDefaults).map(key => {
    if (key.startsWith("[") && key.endsWith("]")) {
      const languageConfigurationDefaults = configurationDefaults[key];
      return Object.keys(languageConfigurationDefaults).map(configurationDefault => ({
        language: key,
        configurationDefault,
        configurationDefaultValue: languageConfigurationDefaults[configurationDefault]
      }));
    } else {
      return {
        configurationDefault: key,
        configurationDefaultValue: configurationDefaults[key]
      };
    }
  });
}
function propsFunctionByContribution(tableName) {
  switch (tableName) {
    case Contributions.CONFIGURATION:
      return propsConfiguration;
    case Contributions.DEBUGGERS:
      return propsDebuggers;
    case Contributions.DOCUMENTATION:
      return propsDocumentation;
    case Contributions.ICONS:
      return propsIcons;
    case Contributions.TERMINALPROFILES:
      return propsTerminalProfiles;
    case Contributions.SEMANTICTOKENSCOPES:
      return propsSemanticTokenScopes;
    case Contributions.PROBLEMMATCHERS:
      return propsProblemMatchers;
    case Contributions.CONFIGURATIONDEFAULTS:
      return propsConfigurationDefaults;
    case Contributions.CSSCUSTOMDATA:
    case Contributions.HTMLCUSTOMDATA:
    case Contributions.MARKDOWNPREVIEWSCRIPTS:
    case Contributions.MARKDOWNPREVIEWSTYLES:
      return propsArray;
    case Contributions.MENUS:
    case Contributions.VIEWS:
    case Contributions.VIEWSCONTAINERS:
      return propsWithAreas;
    case Contributions.COMMANDS:
    case Contributions.KEYBINDINGS:
      return propsFlatObjectOrObjectArray;
    case Contributions.CODEACTIONS:
    case Contributions.COLORS:
    case Contributions.LANGUAGES:
    case Contributions.RESOURCELABELFORMATTERS:
    case Contributions.SUBMENUS:
      return propsNestedObject;
    case Contributions.AUTHENTICATION:
    case Contributions.BREAKPOINTS:
    case Contributions.CONTINUEEDITSESSION:
    case Contributions.CUSTOMEDITORS:
    case Contributions.GRAMMARS:
    case Contributions.HTMLLANGUAGEPARTICIPANTS:
    case Contributions.ICONTHEMES:
    case Contributions.JSONVALIDATION:
    case Contributions.LOCALIZATIONS:
    case Contributions.NOTEBOOKPRELOAD:
    case Contributions.NOTEBOOKRENDERER:
    case Contributions.NOTEBOOKS:
    case Contributions.PROBLEMPATTERNS:
    case Contributions.PRODUCTICONTHEMES:
    case Contributions.SEMANTICTOKENMODIFIERS:
    case Contributions.SEMANTICTOKENTYPES:
    case Contributions.SNIPPETS:
    case Contributions.TASKDEFINITIONS: // TODO: could improve "properties" and "required" data
    case Contributions.THEMES:
    case Contributions.TYPESCRIPTSERVERPLUGINS:
    case Contributions.VIEWSWELCOME:
    case Contributions.WALKTHROUGHS:
    default:
      return propsPlain;
  }
}
function getContributions(packageFile) {
  const contributions = JSON.parse(packageFile).contributes;
  return contributions;
}
function escapeMarkdown(str = "") {
  return str.replaceAll(/([*_])/gi, "\\$1");
}
function getTablesInfo(inputFile) {
  const tablesToInsertMatched = [...inputFile.matchAll(/(?<=\r?\n|^)\[\/\/\]: # [("]vscode-table-(.+)\((.+)\)[)"](?=\r?\n|$)/gi)];
  const tablesToInsert = tablesToInsertMatched.reduce((accTables, currTable) => {
    const [match, contribution, columnsString] = currTable;
    const columns = columnsString.split("|").reduce((accColumns, currColumn) => {
      const [name, alias] = currColumn.split(":");
      const columnHeader = alias || name;
      accColumns[name] = {
        columnHeader,
        values: [],
        // width: stringWidth(columnHeader),
        width: stringWidth(columnHeader)
      };
      return accColumns;
    }, {});
    accTables.push({
      contribution,
      columns,
      index: currTable.index || 0,
      endIndex: (currTable.index || 0) + match.length
    });
    return accTables;
  }, []);
  return tablesToInsert;
}
export function getTablesWithData(packageFile, inputFile) {
  const tables = getTablesInfo(inputFile);
  const contributions = getContributions(packageFile);
  if (!contributions) throw new Error("Missing contributions property in package");
  for (const table of tables) {
    const contribution = contributions[table.contribution];
    if (!contribution) continue;
    const propsFunction = propsFunctionByContribution(table.contribution);
    const contributionProps = propsFunction(contribution);
    for (const contributionEntry of contributionProps) {
      for (const [columnName, columnProps] of Object.entries(table.columns)) {
        let value = contributionEntry[columnName];
        if (typeof value !== "string") value = JSON.stringify(value);
        value = escapeMarkdown(value);
        columnProps.values.push(value);
        if (value && stringWidth(value) > columnProps.width) {
          columnProps.width = stringWidth(value);
        }
      }
    }
  }
  return tables;
}